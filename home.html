<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="description" content="Manuel Llamas Portfolio">
  <meta name="keywords" content="Visual Effects Compositing Media Computer Graphics Photoscan Photography">
  <meta name="author" content="Manuel Llamas">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Manuel Llamas Portfolio</title>

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-NM4H317MLM"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());
    gtag('config', 'G-NM4H317MLM');
  </script>

  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #000;
    }

    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    .container {
      position: relative;
      z-index: 2;
      color: white;
      text-align: center;
      height: 80vh;
      padding: 20px;
      pointer-events: none;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>
</head>

<body>

  <div id="canvas-container"></div>

  <div class="container">
  </div>

  <script>
    // Configuration
    const imageURL = 'images/nyequi.jpg';
    const depthURL = 'images/nyequi_depth_00001_.png';
    const particleSize = 2;
    const depthStrength = .8; // User adjusted

    // Scene Setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 1; // User adjusted
    camera.position.y = .05; // User adjusted

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // Load Textures
    const loader = new THREE.TextureLoader();

    Promise.all([
      new Promise(resolve => loader.load(imageURL, resolve)),
      new Promise(resolve => loader.load(depthURL, resolve))
    ]).then(([texture, depthTexture]) => {

      // Config based on image aspect ratio
      const imgWidth = texture.image.width;
      const imgHeight = texture.image.height;
      const aspect = imgWidth / imgHeight;

      // Create Geometry
      // User adjusted to 2000
      const segmentsW = 2000;
      const segmentsH = Math.round(segmentsW / aspect);
      const geometry = new THREE.PlaneGeometry(aspect * 2, 2, segmentsW, segmentsH);

      // Shader Material
      const material = new THREE.ShaderMaterial({
        uniforms: {
          uTexture: { value: texture },
          uDepthMap: { value: depthTexture },
          uPointSize: { value: particleSize },
          uDepthStrength: { value: depthStrength },
          uMouse: { value: new THREE.Vector2(0, 0) }
        },
        vertexShader: `
        uniform sampler2D uDepthMap;
        uniform float uPointSize;
        uniform float uDepthStrength;
        uniform vec2 uMouse;
        varying vec2 vUv;
        varying vec3 vPosition;

        void main() {
          vUv = uv;
          
          // Sample depth
          float depth = 1.0 - texture2D(uDepthMap, uv).r;
          
          // Displace Z
          vec3 pos = position;
          pos.z += depth * uDepthStrength; 

          vPosition = pos;

          gl_PointSize = uPointSize;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
      `,
        fragmentShader: `
        uniform sampler2D uTexture;
        varying vec2 vUv;

        void main() {
          vec4 color = texture2D(uTexture, vUv);
          // Optional: discard dark pixels
          if (color.r < 0.05 && color.g < 0.05 && color.b < 0.05) discard;
          gl_FragColor = color;
        }
      `,
        transparent: false,
        blending: THREE.NormalBlending,
        depthTest: true,
        depthWrite: true
      });

      // Create Point Cloud
      const points = new THREE.Points(geometry, material);
      scene.add(points);

      // --- 3D MENU SIGNS ---
      const menuGroup = new THREE.Group();
      scene.add(menuGroup);
      const menuItems = [];
      const menuLabels = [
        { text: 'XR', pos: 'TL', action: '3D/index.html' },
        { text: 'AI', pos: 'TR', action: 'https://phantasmalabs.netlify.app/synth.html' },
        { text: 'VFX', pos: 'BL', action: 'vfx/index.html' },
        { text: 'Photo', pos: 'BR', action: 'photo/index.html' }
      ];

      const fontLoader = new THREE.FontLoader();
      // Using a reliable CDN for the font (Helvetiker Regular)
      fontLoader.load('https://threejs.org/examples/fonts/helvetiker_regular.typeface.json', (font) => {

        const matNormal = new THREE.MeshBasicMaterial({ color: 0xffffff }); // White
        const matHover = new THREE.MeshBasicMaterial({ color: 0xff0000 });  // Red

        menuLabels.forEach(item => {
          const textGeo = new THREE.TextGeometry(item.text, {
            font: font,
            size: 0.025, // Halved from 0.05
            height: 0.005, // Halved from 0.01
            curveSegments: 12,
            bevelEnabled: false
          });

          textGeo.computeBoundingBox();
          const centerOffset = -0.5 * (textGeo.boundingBox.max.x - textGeo.boundingBox.min.x);
          const centerOffsetY = -0.5 * (textGeo.boundingBox.max.y - textGeo.boundingBox.min.y);
          textGeo.translate(centerOffset, centerOffsetY, 0);

          const mesh = new THREE.Mesh(textGeo, matNormal.clone());
          mesh.userData = {
            isMenu: true,
            originalColor: 0xffffff,
            hoverColor: 0xff0000,
            label: item.text,
            action: item.action
          };

          menuGroup.add(mesh);
          menuItems.push(mesh);

          // Store position logic for resize updates if needed
          item.mesh = mesh;
        });

        updateMenuPositions(); // Initial position
      });

      // Function to position menus in corners
      const updateMenuPositions = () => {
        if (menuItems.length === 0) return;

        // Calculate visible width/height at depth 0.5 (closer to camera)
        // Camera is at z=1. Menu is at z=0.5.
        // Distance from camera = 0.5
        const dist = camera.position.z - 0.5;
        const vH = 2 * Math.tan((camera.fov * Math.PI) / 360) * dist;
        const vW = vH * camera.aspect;

        // Margins - tuned for 0.5 depth
        // Reduced by 50% as requested to be "half distance closer to the center"
        const marginX = vW * 0.225;
        const marginY = vH * 0.2;
        const zPos = 0.5;

        menuLabels.forEach(item => {
          if (!item.mesh) return;

          if (item.pos === 'TL') item.mesh.position.set(-marginX, marginY, zPos);
          if (item.pos === 'TR') item.mesh.position.set(marginX, marginY, zPos);
          if (item.pos === 'BL') item.mesh.position.set(-marginX, -marginY, zPos);
          if (item.pos === 'BR') item.mesh.position.set(marginX, -marginY, zPos);
        });
      };
      // ---------------------

      // Scaling Function (Cover Screen)
      const updateScale = () => {
        const dist = camera.position.z;
        const vH = 2 * Math.tan((camera.fov * Math.PI) / 360) * dist;
        const vW = vH * camera.aspect;
        const planeAspect = aspect;

        // We scale uniformly to cover the screen
        const scale = Math.max(vH / 2, vW / (planeAspect * 2));
        points.scale.set(scale, scale, scale);
      };

      // Initial Scale
      updateScale();

      // Interaction Variables
      let mouseX = 0;
      let mouseY = 0;
      let userHasInteracted = false;
      const windowHalfX = window.innerWidth / 2;
      const windowHalfY = window.innerHeight / 2;

      // Idle Animation Variables
      const startTime = Date.now();
      const idleThreshold = 100;

      // Mouse Listener
      document.addEventListener('mousemove', (event) => {
        userHasInteracted = true;
        // Navigation rotation values (inverted)
        mouseX = (event.clientX - windowHalfX) / windowHalfX;
        mouseY = (event.clientY - windowHalfY) / windowHalfY;

        // Raycasting values (0 to 1 mapping is handled by Raycaster but we need normalized device coordinates -1 to 1)
        rayMouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        rayMouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      });

      // Raycaster for Hover
      const raycaster = new THREE.Raycaster();
      const rayMouse = new THREE.Vector2(-100, -100); // Init off-screen

      // Touch Listener (Mobile)
      document.addEventListener('touchmove', (event) => {
        if (event.touches.length > 0) {
          userHasInteracted = true;
          const touchX = event.touches[0].clientX;
          const touchY = event.touches[0].clientY;
          mouseX = (touchX - windowHalfX) / windowHalfX;
          mouseY = (touchY - windowHalfY) / windowHalfY;
        }
      }, { passive: false });

      // Gyroscope Listener (Mobile)
      const handleOrientation = (event) => {
        if (!event.alpha && !event.beta && !event.gamma) return;

        userHasInteracted = true;

        // Gamma: Left/Right tilt (-90 to 90)
        // Map -45 to 45 -> -1 to 1
        let g = event.gamma || 0;
        if (g > 45) g = 45;
        if (g < -45) g = -45;
        mouseX = (g / 45) * 3; // 3x Multiplier

        // Beta: Front/Back tilt (-180 to 180)
        // Holding phone normally: Beta is around 45 to 90 degrees.
        // Let's assume neutral is 45 degrees. Range 0 to 90.
        // Map 0 to 90 -> -1 to 1
        let b = event.beta || 0;
        // Shift center to 45
        let bNorm = b - 45;
        // Clamp -45 to 45
        if (bNorm > 45) bNorm = 45;
        if (bNorm < -45) bNorm = -45;
        mouseY = (bNorm / 45) * 3; // 3x Multiplier
      };

      window.addEventListener('deviceorientation', handleOrientation);

      // iOS Permission Request
      const requestGyro = () => {
        if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
          DeviceOrientationEvent.requestPermission()
            .then(response => {
              if (response === 'granted') {
                window.addEventListener('deviceorientation', handleOrientation);
              }
            })
            .catch(console.error);
        }
        // Remove listener after first interaction attempt
        document.removeEventListener('click', requestGyro);
        document.removeEventListener('touchstart', requestGyro);
      };

      document.addEventListener('click', requestGyro);
      document.addEventListener('touchstart', requestGyro);

      document.addEventListener('touchstart', () => {
        userHasInteracted = true;
      }, { passive: false });

      // Click Listener
      document.addEventListener('click', (event) => {
        // Trigger generic interaction
        userHasInteracted = true;

        // Check Raycast
        raycaster.setFromCamera(rayMouse, camera);
        const intersects = raycaster.intersectObjects(menuItems);

        if (intersects.length > 0) {
          const action = intersects[0].object.userData.action;
          if (action) {
            if (window.parent && window.parent.loadContent) {
              window.parent.loadContent(action);
            } else {
              // Fallback
              window.location.href = action;
            }
          }
        }
      });




      // Handle Resize
      // Force aggressive resize checking for mobile address bars etc.
      const onResize = () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setSize(window.innerWidth, window.innerHeight);
        updateScale();
        updateMenuPositions();
      };

      window.addEventListener('resize', onResize);
      window.addEventListener('orientationchange', onResize);

      // Animation Loop
      const animate = () => {
        requestAnimationFrame(animate);

        const now = Date.now();
        let targetRotX = 0;
        let targetRotY = 0;

        // Condition: If user has NOT interacted, AND we passed threshold, do idle.
        if (!userHasInteracted && (now - startTime > idleThreshold)) {
          // Idle Mode: Smooth left-to-right sway
          // Amplitude increased 3x as requested (0.1 -> 0.3, 0.05 -> 0.15)
          targetRotY = Math.sin(now * 0.0005) * 0.3;
          targetRotX = Math.cos(now * 0.0003) * 0.15;
        } else if (userHasInteracted) {
          // Active Mode
          targetRotX = -mouseY * 0.3; // Inverted
          targetRotY = -mouseX * 0.3; // Inverted
        }

        // Smooth interpolation
        points.rotation.x += 0.05 * (targetRotX - points.rotation.x);
        points.rotation.y += 0.05 * (targetRotY - points.rotation.y);

        points.rotation.x += 0.05 * (targetRotX - points.rotation.x);
        points.rotation.y += 0.05 * (targetRotY - points.rotation.y);

        // Raycasting Logic
        if (menuItems.length > 0) {
          // Update Raycaster
          raycaster.setFromCamera(rayMouse, camera);
          const intersects = raycaster.intersectObjects(menuItems);

          // Reset all to white
          menuItems.forEach(mesh => {
            mesh.material.color.setHex(0xffffff);
          });

          // Set hovered to red
          if (intersects.length > 0) {
            intersects[0].object.material.color.setHex(0xff0000);
            document.body.style.cursor = 'pointer';
          } else {
            document.body.style.cursor = 'default';
          }
        }

        renderer.render(scene, camera);
      };

      animate();

    });

  </script>

</body>

</html>